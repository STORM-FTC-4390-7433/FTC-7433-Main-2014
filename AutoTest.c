#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S3,     touch1,         sensorTouch)
#pragma config(Sensor, S4,     touch2,         sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     frontLeftMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     frontRightMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     backLeftMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     backRightMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     frontLiftMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     backLiftMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     intakeMotor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    clawServo,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    gateServo,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define COMPETITION

#include "JoystickDriver.c"
#include "claw.h"
#include "claw.c"
#include "drive.h"
#include "drive.c"
#include "lift.h" //Import other files called in this one
#include "lift.c"
#include "intake.h"
#include "intake.c"
#include "gate.h"
#include "gate.c"
//#include "gyro.h"
//GyroSys gyr;
//#include "gyro.c"

DriveSys drive;
LiftSys lift;
IntakeSys intake; //Control variable declaration
GateSys gate;
ClawSys claw;

void initializeRobot(){ //Robot initiliazation code
	drive.backLeft = backLeftMotor;
	drive.backRight = backRightMotor;
	drive.frontRight = frontRightMotor; //Control variable declaration
	drive.frontLeft = frontLeftMotor; //Declare motor control variables
	gate.gate = gateServo;
	lift.frontLift = frontLiftMotor;
	lift.backLift = backLiftMotor;
	intake.intake = intakeMotor;
	//gyr.gyroscope = gyroSensor;
	claw.claw = clawServo;

	return;
}

task main()
{

//Variable for the robot's location
int robo_loc = 0;
//Variable for the robot's next target
int nxtTarget = 0;
typedef enum {
	RAMP = 0,
	FLOOR = 1,
	ROLLING_GOAL = 2,
	KICKSTAND = 3,
	PARKING_ZONE = 4
} location;

typedef enum {
	ROLLING = 0,
	KICK = 1,
	PARKING = 2
} nextTarget;

void rampToRollingGoal () {
// Drive off ramp, to rolling goal
// Dump preloaded balls, latch on
	robo_loc = (short)ROLLING_GOAL;
	if (SensorValue (touch2) == 1) {
		nxtTarget = (short)PARKING;
	} else {
		nxtTarget = (short)KICK;
	}
	return;
}

void rampToKickstand () {
updateDriveSys(drive, 100, 100);
wait1Msec(2000);
updateDriveSys(drive, 0, 0);
//IR sensor code/function
}

void rampToParkingZone () {
//TODO: Determine Experimentally
}

void rollingGoalToKickstand () {
//TODO: Determine Experimentally
}

void rollingGoalToParkingZone () {
//update function to grab goal(unsure of the function at the moment)
updateDriveSys(drive, -100, 100);
wait1Msec(2000);
updateDriveSys(drive, 100, 100);
wait1Msec(2000);
updateDriveSys(drive, 100, -100);
wait1Msec(2000);
updateDriveSys(drive, -100, -100);
//update function to release goal

}

void kickstandToRollingGoal () {
//TODO: Determine Experimentally
}

void kickstandToParkingZone () {
//TODO: Determine Experimentally
}

void floorToRollingGoal () {
updateDriveSys(drive, -100, -100);
wait1Msec(3500);//Possibly change to ultrasonic detection
updateDriveSys(drive, 0, 0);
}

void floorToKickstand () {
updateDriveSys(drive, 100, 100);
wait1Msec(2000);
updateDriveSys(drive, 0, 0);
//State IR or IR function
}

bool a = true;

task main() {
	if (SensorValue (touch1) == 1) {		// This code sets the starting position of the robot based
		robo_loc = (short)RAMP;						// on whether or not a touch sensor is pressed
} else {
	robo_loc = (short)FLOOR;
}
if (SensorValue (color1) == ‘red’) {					// This code sets the position of the next target
	nxtTarget = (short)ROLLING;									// based on the reading of a color sensor. It will
} else if (SensorValue (color1) == ‘blue’) {	// be reading off of a colored wheel.
	nxtTarget = (short)KICKSTAND;
} else {
	nxtTarget = (short)PARKING_ZONE;
}
while (a) {
		switch(robo_loc) {
case (short)RAMP:
switch(nxtTarget) {
	case (short)ROLLING:
		rampToRollingGoal ();
	case (short)KICK:
		rampToKickstand();
	case (short)PARKING:
		rampToParkingZone();
	default:
		a = false;
		break;
}
				break;
case (short)FLOOR:
switch(nxtTarget) {
	case (short)ROLLING_GOAL:
		floorToRollingGoal ();
	case (short)KICK:
		floorToKickstand();
					default:
		a = false;
		break;
}
				break;
case ROLLING:
switch(nxtTarget) {
	case (short)KICK:
		rollingGoalToKickstand ();
	case (short)PARKING:
		rollingGoalToParkingZone();
					default:
		a = false;
		break;
}
				break;
case (short)KICK:
switch(nextTarget) {
	case (short)ROLLING:
		kickstandToRollingGoal ();
	case (short)PARKING:
		kickstandToParkingZone();
					default:
		a = false;
		break;
}
				break;
case PARKING_ZONE:
				a = false;
				break;
		}
	}
}
